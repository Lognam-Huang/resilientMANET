import numpy as np
from sklearn.cluster import DBSCAN

# Assuming these utility functions are defined elsewhere in your project
# def path_is_blocked(obstacles, nodeA, nodeB):
#     # Function to determine if the path between nodeA and nodeB is blocked by any obstacles
#     pass

# def calculate_data_rate(UAVInfo, UAV_position, ground_user_position, block_or_not):
#     # Function to calculate data rate between a UAV and a ground user based on position and obstacles
#     pass

def is_position_inside_block(position, blocks):
    x, y, z = position
    for block in blocks:
        bx, by, bz = block["bottomCorner"]
        sx, sy = block["size"]
        h = block['height']
        if (bx <= x <= bx + sx) and (by <= y <= by + sy) and (bz <= z <= bz + h):
            return True
    return False

from functions.path_is_blocked import path_is_blocked
from classes.Nodes import Nodes
from sklearn.cluster import DBSCAN

from functions.calculate_data_rate import *

def generate_3D_heatmap(ground_users, scene_data, weights, sparsity_parameter=1, target_user_indices=None):
    """
    Generate a 3D heatmap of connection scores and GU bottlenecks for UAV positioning.

    Parameters:
 
    Returns:
    heatmap: A dictionary where each key is a coordinate tuple (x, y, z), and the value is a tuple (connection_score, GU_bottleneck).
    """
    x_length = scene_data['scenario']['xLength']
    y_length = scene_data['scenario']['yLength']
    heatmap = {}

    print("Calculating heatmap for GUs: "+str(target_user_indices))

    if target_user_indices is None:
        target_user_indices = range(len(ground_users))

    for altitude in range(scene_data['UAV']['min_height'], scene_data['UAV']['max_height'] + 1):
        for x in range(0, x_length, sparsity_parameter):
            for y in range(0, y_length, sparsity_parameter):

                if is_position_inside_block(position=(x, y, altitude), blocks=scene_data['blocks']):
                    continue

                connection_score = 0
                gu_bottleneck = float('inf')

                for user_index in target_user_indices:
                    user = ground_users[user_index]
                    viewpoint = Nodes([x, y, altitude])

                    if not path_is_blocked(scene_data['blocks'], viewpoint, user):
                        connection_score += weights['GU']  # Increment connection score based on GU weight
                        data_rate = calculate_data_rate(scene_data['UAV'], viewpoint.position, user.position, False)
                        gu_bottleneck = min(gu_bottleneck, data_rate)  # Update bottleneck with minimum data rate

                        # print(data_rate)
                        # print(gu_bottleneck)

                heatmap[(x, y, altitude)] = (connection_score, gu_bottleneck)

    return heatmap

def select_optimal_uav_position(heatmap, uncovered_gu_indices, ground_users, blocks):
    """
    Select the best UAV position based on the generated 3D heatmap.

    Parameters:
    heatmap: Dictionary generated by generate_3D_heatmap with positions and their scores.
    uncovered_gu_indices: List of indices of ground users that are not yet covered by any UAV.

    Returns:
    best_position: The coordinate (x, y, z) of the optimal UAV position.
    updated_uncovered_gu_indices: Updated list of uncovered ground user indices after placing the UAV.
    """
    best_position = None
    max_score = -float('inf')
    best_gu_bottleneck = float('inf')

    for position, (connection_score, gu_bottleneck) in heatmap.items():
        if connection_score > max_score or (connection_score == max_score and gu_bottleneck > best_gu_bottleneck):
            best_position = position
            max_score = connection_score
            best_gu_bottleneck = gu_bottleneck
        
    # updated_uncovered_gu_indices = [index for index in uncovered_gu_indices if not path_is_blocked(blocks, Nodes(best_position), ground_users[index])]
    updated_uncovered_gu_indices = [index for index in uncovered_gu_indices if path_is_blocked(blocks, Nodes(best_position), ground_users[index])]

    print("New UAV position is found: "+str(best_position)+" whose connection score is: "+str(max_score)+", with bottleneck: "+str(best_gu_bottleneck))

    return best_position, updated_uncovered_gu_indices

def find_optimal_uav_positions(ground_users, uavs, clustering_epsilon, min_cluster_size, scene_data, weights, sparsity_parameter=1, print_para=False, print_prog=False):
    uncovered_gu_indices = list(range(len(ground_users)))
    uav_positions = []
    available_uav_indices = list(range(len(uavs)))  # Track available UAVs by their indices

    while available_uav_indices:
        print("Available UAVs: "+str(available_uav_indices))
        if uncovered_gu_indices:
            print("Covering GUs...")
            heatmap = generate_3D_heatmap(ground_users, scene_data, weights, sparsity_parameter, target_user_indices=uncovered_gu_indices)
            best_position, uncovered_gu_indices = select_optimal_uav_position(heatmap, uncovered_gu_indices, ground_users, scene_data['blocks'])
            uav_positions.append(best_position)

            # Remove the used UAV from the available list
            available_uav_indices.pop(0)  # Assuming you assign UAVs in order, adjust this if necessary


            print("There are uncovered GUs: "+str(uncovered_gu_indices))
        else:
            # After covering all GUs, optimize load distribution using DBSCAN
            print("Optimizing GUs...")

            # Step 1: Calculate which UAV each GU prefers based on the maximum data rate
            gu_to_uav_map = {uav_index: [] for uav_index in range(len(uav_positions))}

            for gu_index in range(len(ground_users)):
                best_uav = None
                max_data_rate = -float('inf')

                for uav_index, uav_position in enumerate(uav_positions):
                    # if not path_is_blocked(scene_data['blocks'], Nodes(uav_position), ground_users[gu_index]):
                    data_rate = calculate_data_rate(scene_data['UAV'], uav_position, ground_users[gu_index].position, path_is_blocked(scene_data['blocks'], Nodes(uav_position), ground_users[gu_index]))
                    if data_rate > max_data_rate:
                        max_data_rate = data_rate
                        best_uav = uav_index

                if best_uav is not None:
                    gu_to_uav_map[best_uav].append(gu_index)

            # Step 2: Find the UAV with the maximum load (most GUs connected)
            max_load_uav = max(gu_to_uav_map, key=lambda k: len(gu_to_uav_map[k]))
            gu_indices_for_max_uav = gu_to_uav_map[max_load_uav]

            print("Optimized UAV is: "+str(max_load_uav)+", with covered GUs: "+str(gu_indices_for_max_uav))

            # Step 3: Apply DBSCAN to split GUs into two clusters
            gu_positions_for_max_uav = [ground_users[index].position for index in gu_indices_for_max_uav]
            clustering = DBSCAN(eps=clustering_epsilon, min_samples=min_cluster_size).fit(gu_positions_for_max_uav)
            cluster_labels = clustering.labels_

            clusters = {}
            for cluster in set(cluster_labels):
                if cluster == -1:
                    continue  # Skip noise points
                cluster_indices = [gu_indices_for_max_uav[i] for i in range(len(cluster_labels)) if cluster_labels[i] == cluster]
                clusters[cluster] = cluster_indices

            print("DBSCAN is applied, we find "+str(len(clusters))+" clusters")

            # Check if we have exactly two clusters
            if len(clusters) != 2:
                print("DBSCAN did not find exactly two clusters, skipping optimization for this UAV.")
                break  # In case we don't find exactly two clusters, skip optimization

            # Step 4: Find new positions for the UAVs based on the clusters
            new_positions = []
            for cluster in clusters.values():
                cluster_heatmap = generate_3D_heatmap(ground_users, scene_data, weights, sparsity_parameter, target_user_indices=cluster)
                best_cluster_position, _ = select_optimal_uav_position(cluster_heatmap, cluster, ground_users, scene_data['blocks'])
                new_positions.append(best_cluster_position)

            # if len(new_positions) == 2:
            print("Optimization done, found UAV is updated from "+str(uav_position[max_load_uav])+" to "+str(new_positions[0])+". Meanwhile the new UAV will locate at: "+str(new_positions[1]))
            # Update the position of the overloaded UAV
            uav_positions[max_load_uav] = new_positions[0]

            # Add a new UAV position for the second cluster
            uav_positions.append(new_positions[1])
            available_uav_indices.pop(0)


            # if len(gu_indices_for_max_uav) < min_cluster_size:
            #     break  # Exit if the largest cluster is too small to optimize further

            # # Apply DBSCAN clustering to the GUs covered by this UAV
            # clustering = DBSCAN(eps=clustering_epsilon, min_samples=min_cluster_size).fit([ground_users[index].position for index in gu_indices_for_max_uav])
            # cluster_labels = clustering.labels_

            # for cluster in set(cluster_labels):
            #     if cluster == -1:
            #         continue  # Skip noise points
            #     cluster_indices = [gu_indices_for_max_uav[i] for i in range(len(cluster_labels)) if cluster_labels[i] == cluster]

            #     # Generate heatmap for the cluster to optimize UAV position
            #     cluster_heatmap = generate_3D_heatmap(ground_users, scene_data, weights, sparsity_parameter, target_user_indices=cluster_indices)
            #     best_cluster_position, _ = select_optimal_uav_position(cluster_heatmap, cluster_indices, ground_users, scene_data['blocks'])

            #     # Only add a new UAV position if there are available UAVs
            #     if available_uav_indices:
            #         uav_positions.append(best_cluster_position)
            #         available_uav_indices.pop(0)  # Remove the used UAV from the available list
            #     else:
            #         print("No more available UAVs.")
            #         break  # No more UAVs to use, exit the loop

                # ---

                # gu_indices_for_this_uav = [index for index in range(len(ground_users)) if path_is_blocked(scene_data['blocks'], Nodes(uav_position), ground_users[index]) == False]

                # if len(gu_indices_for_this_uav) >= min_cluster_size:
                #     clustering = DBSCAN(eps=clustering_epsilon, min_samples=min_cluster_size).fit([ground_users[index].position for index in gu_indices_for_this_uav])
                #     cluster_labels = clustering.labels_

                #     for cluster in set(cluster_labels):
                #         if cluster == -1:
                #             continue  # Skip noise points
                #         cluster_indices = [gu_indices_for_this_uav[i] for i in range(len(cluster_labels)) if cluster_labels[i] == cluster]
                #         # cluster_heatmap = generate_3D_heatmap(ground_users, obstacles, area_info, min_altitude, max_altitude, weights, uav_info ,sparsity_parameter, target_user_indices=cluster_indices)
                #         cluster_heatmap = generate_3D_heatmap(ground_users, scene_data, weights, sparsity_parameter, target_user_indices=uncovered_gu_indices)
                #         best_cluster_position, _ = select_optimal_uav_position(cluster_heatmap, cluster_indices, ground_users, scene_data['blocks'])
                #         uav_positions.append(best_cluster_position)

    return uav_positions
